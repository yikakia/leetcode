# 137.只出现一次的数字 II
[https://leetcode-cn.com/problems/single-number-ii](https://leetcode-cn.com/problems/single-number-ii) 
## 原题
给你一个整数数组  `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。** 请你找出并返回那个只出现了一次的元素。

 

 **示例 1：** 

```

输入：nums = [2,2,3,2]
输出：3

```
 **示例 2：** 

```

输入：nums = [0,1,0,1,0,1,99]
输出：99

```
 

 **提示：** 
-  `1 <= nums.length <= 3 * 10^4` 
-  `-2^31 <= nums[i] <= 2^31 - 1` 
-  `nums` 中，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次** 
 

 **进阶：** 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

 
**标签**
`位运算` 


## 统计每位的出现 1 的个数
```go
func singleNumber(nums []int) int {
    ans := int32(0)
    for i := 0; i < 32; i++ {
        total := int32(0)
        for _, num := range nums {
            total += int32(num) >> i & 1
        }
        if total%3 > 0 {
            ans |= 1 << i
        }
    }
    return int(ans)
}
```
>执行用时: 4 ms
内存消耗: 3.4 MB


原理就是把数字拆成 32 个 bit ，然后统计每个数的每一位的 1 出现的次数。因为只会出现三个 1 和三个 0 的情况，所以如果不计算只出现一次的数的话，最后的结果一定是 3 的倍数。

而不为倍数，就说明只出现一次的那个数的这个位上为 1 。最后把每一位都做同样的操作即可。