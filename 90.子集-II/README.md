# 90.子集 II
[https://leetcode-cn.com/problems/subsets-ii](https://leetcode-cn.com/problems/subsets-ii) 
## 原题
给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。
 

 **示例 1：** 

```

输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]

```
 **示例 2：** 

```

输入：nums = [0]
输出：[[],[0]]

```
 

 **提示：** 
-  `1 <= nums.length <= 10` 
-  `-10 <= nums[i] <= 10` 
 
**标签**
`数组` `回溯算法` 


## 迭代法
```go
func subsetsWithDup(nums []int) (res [][]int) {
	sort.Slice(nums, func(i, j int) bool {
		return nums[i] < nums[j]
	})

	res = append(res, []int{})
	k := 0
	for i := range nums {
		pre := k
		var start, end int
		k = len(res)
		if i > 0 && nums[i] == nums[i-1] {
			start, end = pre, k
		} else {
			start, end = 0, k
		}
		for j := start; j < end; j++ {
			t := append([]int(nil), res[j]...)
			t = append(t, nums[i])
			res = append(res, t)
		}
	}
	return
}
```
>执行用时: 0 ms
内存消耗: 2.5 MB

原理很简单，就是对已经产生的数组的末尾添加新的数据。比如 `1,2,3,4`
```
start  []
1      [] [1]
2      [] [1] [2] [1,2]
3      [] [1] [2] [1,2] [3] [1,3] [2,3] [1,2,3]
4      [] [1] [2] [1,2] [3] [1,3] [2,3] [1,2,3] [4] [1,4] [2,4] [1,2,4] [3,4] [1,3,4] [2,3,4] [1,2,3,4]
```
初始的数据是空子集，然后对空子集填入新的数据，形成新的数据。

在遍历的时候就是取出之前的数据，然后添加在末尾即可。

要注意到的是这里有重复的元素，所以需要先进行一次排序，然后就能通过查看当前遍历到的元素和之前的元素是否相同，如果相同就应该选择取出基于前面的元素新生成的数据来添加，因为在新生成的数据之前的数据因为已经和相同的元素组合过了，所以如果还要组合的话就会出现重复。

这里用 1 2 2 3 举例
```
start  []
      ^  ^
1      [] [1]
         ^   ^
2      [] [1] [2] [1,2]
             ^         ^
2      [] [1] [2] [1,2] [2,2] [1,2,2] 
                       ^             ^            
3      [] [1] [2] [1,2] [2,2] [1,2,2] [3] [1,3] [2,3] [1,2,3] [2,2,3] [1,2,2,3] 
                                     ^                                         ^
```

这里就是标出的上次新增的区域。如果和上个元素重复，就只用上次新增的组合进行填充，不然的话就从空集开始填充所有的组合。