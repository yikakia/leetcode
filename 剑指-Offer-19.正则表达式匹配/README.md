# 剑指 Offer 19. 正则表达式匹配
[https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

## 递归法
```go
func isMatch(s string, p string) bool {
	ns := len(s)
	np := len(p)

	// 匹配完成
	if ns == 0 && np == 0 {
		return true
	}
	// 字符串没用完，模式用完了
	if ns != 0 && np == 0 {
		return false
	}
	// 字符串用完了，模式没用完
	if ns == 0 && np != 0 {
		// 有*的时候就要继续匹配
		if np >= 2 && p[1] == '*' {
			return isMatch(s, p[2:])
		}
		// 没*就报错
		return false
	}

	if np >= 2 && p[1] == '*' {
		heads := 0
		for heads < ns && equal(s[heads], p[0]) {
			heads++
			break
		}
		// 有匹配可以跳过`s`也可以不跳过`s`
		if heads > 0 {
			return isMatch(s[1:], p) || isMatch(s, p[2:])
		}
		// 没有匹配不能跳过`s`
		return isMatch(s[:], p[2:])
	}
	if equal(s[0], p[0]) {
		return isMatch(s[1:], p[1:])
	}
	return false
}
func equal(a, b byte) bool {
	if a == '.' || b == '.' || a == b {
		return true
	}
	return false
}
```
>执行用时：20 ms, 在所有 Go 提交中击败了32.32%的用户
内存消耗：2.1 MB, 在所有 Go 提交中击败了77.65%的用户

坑很多，让我慢慢来写。

主要是通配符的处理很麻烦。基本的思路很简单，按照规则，从头到尾依次匹配。中间有不匹配的就返回错误就行。因为是从头到尾的，所以感觉可以靠递归来写。

但是坑点就在这里出现了，主要是`按照规则`说起来简单实现起来难。其中最主要的就是对于`*`的处理。

对于 `?*` 而言，它可以匹配`0`个元素，也可以匹配`1`个元素，也可以匹配`n`个元素。这些不同的匹配数对于结果而言都有可能。

比如对于`s = "aaa"` 和 `p = "a*a"` 而言，这里的`a*`可以匹配` `也可以匹配`a`，还可以匹配`aa`和`aaa`。这个时候我们要做的就是选择遍历每种可能性，具体实现的话大概就是下面这个样子

- 当 `*` 能够匹配到时，就遍历以下几种情况
    - 查询`s[1:]`和`p[:]`
        这里是匹配下一个`s`，并且认为`?*`还没有匹配完
    - 查询`s[:]`和`p[2:]`
        这里是继续匹配现在的`s`，并且认为`?*`匹配到了`0`个元素

- 当`*`不能匹配的时候，就直接跳到下一个匹配
    - 查询`s[:]`和`p[2:]`
        这里是因为不能匹配，所以就跳到下一个匹配规则

对于其他情况就很简单了，就是相当于检查边界条件

- 当 `len(s)==0`并且`len(p)==0`时，就是匹配完成
    `return true`

- 当 `len(s)!=0`并且`len(p)==0`时，就是模式匹配失败
    `return false`

- 当 `len(s)==0`并且`len(p)!=0`时，有以下几种情况
    - 如果`p`的下一个匹配模式是`?*`的形式，那么可以跳过这个匹配模式，到再下一个匹配模式中
    - 如果不是的话，那就是不能匹配，直接报错
        `return false`

最后整理以下的话就是下面的流程

1. 检查当前的`len(s)`与`len(p)`的关系，看是否直接报错，或是继续匹配下一个
2. 检查下一个匹配模式是不是`?*`，如果是的话就对其进行查询，分别有三种处理方式。
    
    - 继续当前的匹配模式匹配下一个元素
    - 停止当前的匹配模式并继续匹配当前元素

3. 不是`?*`的匹配模式的话，就是一一对应的匹配模式，这时把两个直接对比就可以得到结果

    - 相同则进行下一个匹配项目
    - 不同则返回错误

总的来说就是这样，对于递归而言最重要的是找到合适边界条件，以及设置应该什么时候，怎么递归。

还有种方法就是动态规划递推

## 动态规划
