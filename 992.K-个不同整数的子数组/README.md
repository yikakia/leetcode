# 992.K 个不同整数的子数组
[https://leetcode-cn.com/problems/subarrays-with-k-different-integers/](https://leetcode-cn.com/problems/subarrays-with-k-different-integers/) 
## 原题
给定一个正整数数组 `A`，如果 `A` 的某个子数组中不同整数的个数恰好为 `K`，则称 `A` 的这个连续、不一定独立的子数组为*好子数组*。

（例如，`[1,2,3,1,2]` 中有 `3` 个不同的整数：`1`，`2`，以及 `3`。）

返回 `A` 中*好子数组*的数目。

 

**示例 1：**

```
输入：A = [1,2,1,2,3], K = 2
输出：7
解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].

```
**示例 2：**

```
输入：A = [1,2,1,3,4], K = 3
输出：3
解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].

```
 

**提示：**
- `1 <= A.length <= 20000`
- `1 <= A[i] <= A.length`
- `1 <= K <= A.length`
 
**标签**
`哈希表` `双指针` `Sliding Window` 


## 
```go
func subarraysWithKDistinct(A []int, K int) int {
	n := len(A)
	num1 := make([]int, n+1)
	num2 := make([]int, n+1)
	res := 0
	cnt1, cnt2 := 0, 0
	left1, left2 := 0, 0
	for _, v := range A {
		if num1[v] == 0 {
			cnt1++
		}
		num1[v]++
		for cnt1 > K {
			num1[A[left1]]--
			if num1[A[left1]] == 0 {
				cnt1--
			}
			left1++
		}

		if num2[v] == 0 {
			cnt2++
		}
		num2[v]++
		for cnt2 > K-1 {
			num2[A[left2]]--
			if num2[A[left2]] == 0 {
				cnt2--
			}
			left2++
		}
		res += left2 - left1
	}
	return res
}
```
>执行用时: 52 ms
内存消耗: 6.7 MB

本来这道题是用哈希表来存出现的次数的，但是题目里面有提到数据限制

- `1 <= A.length <= 20000`
- `1 <= A[i] <= A.length`
- `1 <= K <= A.length`

数据的范围为 `1~len(A)`，因此直接用数组也可以存，但是要另外储存当前有多少个不同的元素。

这个滑动窗口是右端点每次向右移，同时分别用两个数组存左侧的出现次数为 `K `和 `K-1` 的范围中的元素个数。

举个例子就好理解了，有数组为 `[1,2,1,2,1,2,3,3]`，`K = 2`

前期没有溢出的时候右端点不断向右移动，直到到了第`K`个元素之前
| 求`K`的 | 求`K-1`的 |
|---|---|
|  `[1,2,1,2,1,2]` | `[2]`  |
|$left1 = 0$|$left2 = 5$|
而`A[left1:left2+1] = [1,2,1,2,1,2]`

当出现了第`K`个元素的时候
| 求`K`的 | 求`K-1`的 |
|---|---|
|  `[2,3]` | `[3]`  |
|$left1 = 5$|$lef2 = 6$|
`A[left1:left2+1] = [2,3]`

这个时候两个都进行了移动。很容易可以想到的是当求`k`的更新了之后，求`k-1`的必然也会更新，这就是后面的起点。

我们每次都是移动的右端点，然后再更新两个左端点。以当前右端点为终点的区间共有多少个子区间呢？答案是`left2 - left1`个。因为`left2`维护的是当前右端点为终点的`k-1`个数的子区间的左端点，所以$[left1,left2)$中的数作为端点都是可以让区间为 $[left1,right]$ 的子区间为 `k`个数的区间。