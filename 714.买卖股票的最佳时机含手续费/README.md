# 714. 买卖股票的最佳时机含手续费
[https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/) 
## 原题
给定一个整数数组 `prices`，其中第 `i` 个元素代表了第 `i` 天的股票价格 ；非负整数 `fee` 代表了交易股票的手续费用。
你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
返回获得利润的最大值。
**注意：** 这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
**示例 1:** 
```
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```
**注意:** 
- `0 < prices.length <= 50000`.
- `0 < prices[i] < 50000`.
- `0 <= fee < 50000`.


## 动规
```go

func maxProfit(prices []int, fee int) int {
	n := len(prices)
	dp1 := -prices[0] // 持有股票时的最大利润
	dp2 := 0          // 不持有股票时的最大利润
	for i := 1; i < n; i++ {
		dp1, dp2 = max(dp1, dp2-prices[i]), max(dp2, dp1+prices[i]-fee)
		// 持有股票时的最大利润取决于 上一天 持有股票时的最大利润 和 不持有股票时的最大利润减去现在的价格
		// 不持有股票时的最大利润取决于 上一天 不持有股票时的最大利润的值不动 和 持有股票时的最大利润加上现在的股价减去手续费
	}
	return dp2
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```
>执行用时: 108 ms
内存消耗: 7.8 MB

简单地说就是用两个量分别记录当天收盘后手中持有股票的话的最大利润`dp1`和手中不持有股票的话的最大利润`dp2`。

我们令`dp1`的初始值为 `-price[0]`，`dp2`的初始值为`0`，然后从第二天的收盘价`price[1]`开始循环，根据上一天的`dp2`减去今天的`price[i]`，然后和上一天的`dp1`进行比较，得到今天的利润。

这里比较费解，其实可以理解成更新最低的买点。`dp1` 记录的是今天收盘后手中持有股票的最大利润，那么更新的时候如果上一天的 `dp1` 大于 上一天的 `dp2-price[i]` 即今天买股票后的最大利润，大于昨天买股票后的最大利润，那么就可以更新了。

而 `dp2` 的更新思路也是类似的，今天收盘后手上不持有股票的最大利润`dp2`应该是昨天的持有股票最大利润`dp1`加上今天的盈利`price[i]-fee`，即`dp1+price[i]-fee`和如果昨天不持有，今天也不买入的最大利润`dp2`的大小。如果今天卖出比起之前不买入都赚，那么就更新。

顺带一提，用这个方法比直接开数组消耗的时间还多，我怀疑是 Go 语言的版本的问题所以导致的内存占用不同。因此我给执行耗时和内存消耗的时候都只给数值，而不给打败多少人了。